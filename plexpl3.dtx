% \iffalse meta-comment
%% File: plexpl3.dtx
%
%  Copyright (c) 2020-2022 Japanese TeX Development Community
%
%  This file is part of the pLaTeX2e system (community edition).
%  -------------------------------------------------------------
%
% \fi
%
%
% \iffalse
% \changes{v1.0}{2020/09/28}{初版：p\TeX{}の条件文を定義}
% \fi
%
% \iffalse
%<*driver>
\NeedsTeXFormat{pLaTeX2e}
\ProvidesFile{plexpl3.dtx}[2020/09/28 v1.0 expl3 additions]
\RequirePackage{plautopatch}
\documentclass[dvipdfmx,a4paper]{jltxdoc}
\GetFileInfo{plexpl3.dtx}
\author{Japanese \TeX\ Development Community}
\title{The \textsf{plexpl3} package}
\date{作成日：\filedate}
\begin{document}
  \newcommand\Lpack[1]{\textsf{#1}}
  \maketitle
  \DocInput{\filename}
\end{document}
%</driver>
% \fi
%
% \LaTeX3 (expl3)で用意されていない「p\TeX{}系列の独自機能」を
% expl3の文法で使えるようにするコードです。
% p\LaTeXe~2020-10-01で新設しました。
%
% \setcounter{StandardModuleDepth}{1}
% \StopEventually{}
%
% \section{コード}
%
% パッケージとして宣言します。
% これで、p\LaTeXe~2020-04-12以前でも
% \file{plexpl3.sty}と\file{plexpl3.ltx}だけ
% 入手すれば同等の機能が使えます。
%    \begin{macrocode}
%<*package>
\NeedsTeXFormat{pLaTeX2e}
\RequirePackage{expl3}
\ProvidesExplPackage{plexpl3}{2020-09-28}{1.0}
  {pTeX/upTeX-specific additions to expl3}
%</package>
%    \end{macrocode}
%
% \LaTeXe~2020-02-02以降では\file{expl3}が標準で
% フォーマットに読み込まれています。この場合は
% \file{plexpl3}の機能をフォーマットに取り込みます。
%    \begin{macrocode}
%<plcore>\ifdefined\ExplSyntaxOn %--- expl3 available BEGIN
%<plcore>\ExplSyntaxOn
%<*plcore|package>
\input plexpl3.ltx
%</plcore|package>
%<plcore>\ExplSyntaxOff
%<plcore>\fi                     %--- expl3 available END
%    \end{macrocode}
%
% \file{platexrelease}のroll-forwardにも登録します。
%    \begin{macrocode}
%<platexrelease>\plIncludeInRelease{2020/10/01}%
%<platexrelease>                   {plexpl3}{Pre-load plexpl3}%
%<platexrelease>\RequirePackage{plexpl3}
%<platexrelease>\plEndIncludeInRelease
%<platexrelease>\plIncludeInRelease{0000/00/00}%
%<platexrelease>                   {plexpl3}{Not loading plexpl3}%
%<platexrelease>% Nothing to do
%<platexrelease>\plEndIncludeInRelease
%    \end{macrocode}
%
% 以下のコードは\file{plexpl3.ltx}に書き出します。
% フォーマットとパッケージからの重複読み込みは禁止します。
%    \begin{macrocode}
%<*code>
\cs_if_exist:NT \__platex_expl_loaded:
  {
    \GenericInfo{}
      {Skipping:~ plexpl3~ code~ already~ part~ of~ the~ format}%
    \endinput
  }
\cs_new:Npn \__platex_expl_loaded: {  }
%    \end{macrocode}
%
% \section{p\TeX{}系列の条件文}
%
% p\TeX{}系列の条件文をexpl3の文法にします。
% \changes{v1.0}{2020/09/28}{初版：p\TeX{}の条件文を定義}
%    \begin{macrocode}
%% additions to l3box.dtx: writing directions (pTeX/upTeX-specific)
\cs_set_eq:NN \platex_direction_yoko: \tex_yoko:D
\cs_set_eq:NN \platex_direction_tate: \tex_tate:D
\cs_set_eq:NN \platex_direction_dtou: \tex_dtou:D
%
\prg_new_conditional:Npnn \platex_if_direction_yoko: { p, T, F, TF }
  { \tex_ifydir:D \prg_return_true: \else: \prg_return_false: \fi: }
\prg_new_conditional:Npnn \platex_if_direction_tate: { p, T, F, TF }
  { \tex_iftdir:D \prg_return_true: \else: \prg_return_false: \fi: }
\prg_new_conditional:Npnn \platex_if_direction_dtou: { p, T, F, TF }
  { \tex_ifddir:D \prg_return_true: \else: \prg_return_false: \fi: }
%
\prg_new_conditional:Npnn \platex_if_box_yoko:N #1 { p, T, F, TF }
  { \tex_ifybox:D #1 \prg_return_true: \else: \prg_return_false: \fi: }
\prg_new_conditional:Npnn \platex_if_box_tate:N #1 { p, T, F, TF }
  { \tex_iftbox:D #1 \prg_return_true: \else: \prg_return_false: \fi: }
\prg_new_conditional:Npnn \platex_if_box_dtou:N #1 { p, T, F, TF }
  { \tex_ifdbox:D #1 \prg_return_true: \else: \prg_return_false: \fi: }
%    \end{macrocode}
%
% \section{expl3の和文文字トークン対応}
%
% \subsection{大文字小文字変換関数の修正}
% \url{https://gist.github.com/zr-tex8r/248ff347172ce16d005897656687a901}
%
% \begin{macro}{\token_if_jachar:NTF}
%   \meta{token} \marg{true code} \marg{false code}
%
% Tests if \meta{token} is a jachar token or not.
%
%    \begin{macrocode}
\bool_lazy_or:nnTF
  { \sys_if_engine_ptex_p: }
  { \sys_if_engine_uptex_p: }
  {
    \use:x
      {
        \prg_new_conditional:Npnn \exp_not:N \token_if_jachar:N ##1
          { p , T ,  F , TF }
          {
%    \end{macrocode}
% A token is a jachar token if and only if
% its meaning string starts with ``\verb*|kanji |''.
%    \begin{macrocode}
            \exp_not:N \str_if_eq:eeTF
              {
                \exp_not:N \exp_after:wN
                \exp_not:N  \__token_delimit_by_kanji:w
                \exp_not:N \token_to_meaning:N ##1
                ? \tl_to_str:n { kanji } ~ \s__token_stop
              }
              { }
              { \exp_not:N \prg_return_true: }
              { \exp_not:N \prg_return_false: }
          }
        \cs_new:Npn \exp_not:N \__token_delimit_by_kanji:w ##1
          \tl_to_str:n { kanji } ~ ##2 \s__token_stop
          {##1}
      }
  }
  {
    \prg_new_conditional:Npnn \token_if_jachar:N #1
      { p , T ,  F , TF }
      { \prg_return_false: }
  }
%    \end{macrocode}
% \end{macro}
%
% Fix for the case-change funcrtions in \file{l3text}.
%
%    \begin{macrocode}
\bool_lazy_or:nnT
  { \sys_if_engine_ptex_p: }
  { \sys_if_engine_uptex_p: }
  {
    \cs_gset_eq:NN \__text_change_case_char_jachar:nnnN
      \__text_change_case_char_auxii:nnnN
  }
\bool_lazy_or:nnF
  { \sys_if_engine_luatex_p: }
  { \sys_if_engine_xetex_p: }
  {
%    \end{macrocode}
% The current implementation for pdftex should be employed
% for all non-Unicode engines.
%    \begin{macrocode}
    \cs_gset:Npn \__text_change_case_char_auxii:nnnN #1#2#3#4
      {
        \int_compare:nNnTF { `#4 } < { "F0 }
          { \__text_change_case_char_UTFviii:nnnNNN }
          { \__text_change_case_char_UTFviii:nnnNNNN }
            {#1} {#2} {#3} #4
      }
  }
\bool_lazy_or:nnT
  { \sys_if_engine_ptex_p: }
  { \sys_if_engine_uptex_p: }
  {
    \cs_gset:Npn \__text_change_case_char:nnnN #1#2#3#4
      {
        \int_compare:nNnTF { `#4 } > { "80 } % why not "7F?
          {
%    \end{macrocode}
% Check if the given character token is a jachar.
%    \begin{macrocode}
            \token_if_jachar:NTF #4
              { \__text_change_case_char_jachar:nnnN }
              {
                \int_compare:nNnTF { `#4 } < { "E0 }
                  { \__text_change_case_char_UTFviii:nnnNN }
                  { \__text_change_case_char_auxii:nnnN }
              }
          }
          { \__text_change_case_char_auxi:nnnN }
            {#1} {#2} {#3} #4
       }
  }
%    \end{macrocode}
%
% Fix for the case-change funcrtions in \file{l3str}.
%
%    \begin{macrocode}
\bool_lazy_or:nnF
  { \sys_if_engine_luatex_p: }
  { \sys_if_engine_xetex_p: }
  {
%    \end{macrocode}
% The current implementation for pdftex should be employed
% for all non-Unicode engines.
%    \begin{macrocode}
    \cs_gset:Npn \__str_change_case_char_UTFviii:nNNN #1#2#3#4
      { \__str_change_case_char_UTFviii:nn {#1} {#2#3#4} }
    \cs_gset:Npn \__str_change_case_char_UTFviii:nNNNN #1#2#3#4#5
      { \__str_change_case_char_UTFviii:nn {#1} {#2#3#4#5} }
  }
\bool_lazy_or:nnT
  { \sys_if_engine_ptex_p: }
  { \sys_if_engine_uptex_p: }
  {
    \cs_gset:Npn \__str_change_case_char:nN #1#2
      {
        \__str_if_recursion_tail_stop_do:Nn #2
          { \__str_change_case_end:wn }
        \int_compare:nNnTF { `#2 } > { "80 }
          {
%    \end{macrocode}
% Check if the given character token is a jachar.
%    \begin{macrocode}
            \token_if_jachar:NTF #2
              { \__str_change_case_char_jachar:nN }
              {
                \int_compare:nNnTF { `#2 } < { "E0 }
                  { \__str_change_case_char_UTFviii:nNN }
                  {
                    \int_compare:nNnTF { `#2 } < { "F0 }
                      { \__str_change_case_char_UTFviii:nNNN }
                      { \__str_change_case_char_UTFviii:nNNNN }
                  }
              }
            {#1} #2
          }
          {
            \__str_change_case_output:fw
              { \use:c { char_str_ #1 case:N } #2 }
            \__str_change_case_loop:nw {#1}
          }
      }
    \cs_new:Npn \__str_change_case_char_jachar:nN #1#2
      {
        \__str_change_case_output:nw {#2}
        \__str_change_case_loop:nw {#1}
      }
  }
%    \end{macrocode}
%
% \subsection{文字コード変換関数の修正}
% \url{https://gist.github.com/h20y6m/6449d1d5d29a71620d19f29f881a0549}
%
% \begin{macro}{\__str_encode_if_extended_char_p:n}
% \begin{macro}{\__str_encode_extended_char:n}
%    \begin{macrocode}
\cs_new:Npn \__str_encode_if_extended_char_p:n #1 { \c_false_bool }
\cs_new:Npn \__str_encode_extended_char:n #1 { }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% Patch for UTF-8 encoding function in \file{l3str-convert}.
%    \begin{macrocode}
\cs_gset:Npn \__str_encode_utf_viii_char:n #1
  {
    \if_predicate:w \__str_encode_if_extended_char_p:n {#1}
      \__str_encode_extended_char:n {#1}
    \else:
      \__str_encode_utf_viii_loop:wwnnw #1 ; - 1 + 0 * ;
        { 128 } {       0 }
        {  32 } {     192 }
        {  16 } {     224 }
        {   8 } {     240 }
      \s__str_stop
    \fi:
  }
%    \end{macrocode}
%
% \begin{macro}{\__str_decode_if_extended_char_p:N}
% \begin{macro}{\__str_decode_extended_char:N}
%    \begin{macrocode}
\cs_new:Npn \__str_decode_if_extended_char_p:N #1 { \c_false_bool }
\cs_new:Npn \__str_decode_extended_char:N #1 { }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% Patch for UTF-8 decoding function in \file{l3str-convert}.
%    \begin{macrocode}
\cs_gset:Npn \__str_decode_utf_viii_start:N #1
  {
    #1
    \if_predicate:w \__str_decode_if_extended_char_p:N #1
      \s__str
      \__str_decode_extended_char:N #1
    \else:
      \if_int_compare:w `#1 < "C0 \exp_stop_f:
        \s__str
        \if_int_compare:w `#1 < "80 \exp_stop_f:
          \int_value:w `#1
        \else:
          \flag_raise:n { str_extra }
          \flag_raise:n { str_error }
          \int_use:N \c__str_replacement_char_int
        \fi:
      \else:
        \exp_after:wN \__str_decode_utf_viii_continuation:wwN
        \int_value:w \int_eval:n { `#1 - "C0 } \exp_after:wN
      \fi:
      \exp_after:wN % ???
    \fi:
    \s__str
    \__str_use_none_delimit_by_s_stop:w {"80} {"800} {"10000} {"110000} \s__str_stop
    \__str_decode_utf_viii_start:N
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Npn \__ptex_tmp:w { }
%    \end{macrocode}
%
% (up\TeX{} only) declare kanji token which has specific kcatcode.
%    \begin{macrocode}
\sys_if_engine_uptex:T
  {
    \group_begin:
      \cs_set:Npn \__ptex_tmp:w #1#2
        {
          \exp_after:wN \cs_new_eq:NN \exp_after:wN #1
            \tex_Ucharcat:D
              \int_eval:n { \tex_jis:D "2121 } ~
              \int_eval:n {#2} \scan_stop:
        }
      \__ptex_tmp:w \c_kcatcode_kanji_token  { 16 }
      \__ptex_tmp:w \c_kcatcode_kana_token   { 17 }
      \__ptex_tmp:w \c_kcatcode_symbol_token { 18 }
      \__ptex_tmp:w \c_kcatcode_hangul_token { 19 }
    \group_end:
  }
%    \end{macrocode}
%
% (up\TeX{} only) get kcatcode of token.
%    \begin{macrocode}
\sys_if_engine_uptex:T
  {
    \cs_new:Npn \__ptex_char_kcatcode:N #1
      {
        \if_catcode:w \exp_not:N #1 \c_kcatcode_kanji_token
          16
        \else:
          \if_catcode:w \exp_not:N #1 \c_kcatcode_kana_token
            17
          \else:
            \if_catcode:w \exp_not:N #1 \c_kcatcode_symbol_token
              18
            \else:
              \if_catcode:w \exp_not:N #1 \c_kcatcode_hangul_token
                19
              \else:
                15
              \fi:
            \fi:
          \fi:
        \fi:
      }
  }
%    \end{macrocode}
%
% define ptex+utf8 encoding.
%
% ptex+utf8 encode function.
%    \begin{macrocode}
\cs_new_protected:cpn { __str_convert_encode_ptex+utf8: }
  {
    \group_begin:
      \cs_set_eq:NN \__str_encode_if_extended_char_p:n
        \__str_encode_if_kanji_char_p:n
      \cs_set_eq:NN \__str_encode_extended_char:n
        \__str_encode_kanji_char:n
      \use:c { __str_convert_encode_utf8: }
    \group_end:
  }
%    \end{macrocode}
%
% Tests whether the Unicode code point \#1 is Japanese character
%    \begin{macrocode}
\int_compare:nNnTF { \tex_jis:D "2121 } = { "3000 }
  {
%    \end{macrocode}
% up\TeX{} with unicode
%    \begin{macrocode}
    \prg_new_conditional:Npnn \__str_encode_if_kanji_char:n #1 { p }
      {
%    \end{macrocode}
% NOTE:
%   \verb|\kcatcode0|--\verb|\kcatcode127| may not be 15,
%   but ASCII ($0$--$127$) never be Japanese character.
%    \begin{macrocode}
        \if_int_compare:w #1 < "80 \exp_stop_f:
          \prg_return_false:
        \else:
          \if_int_compare:w \tex_kcatcode:D #1 = 15 \exp_stop_f:
            \prg_return_false:
          \else:
            \prg_return_true:
          \fi:
        \fi:
      }
  }
  {
%    \end{macrocode}
% p\TeX{} or up\TeX{} with euc/sjis
%    \begin{macrocode}
    \prg_new_conditional:Npnn \__str_encode_if_kanji_char:n #1 { p }
      {
%    \end{macrocode}
% If specified Unicode code point cannot convert to internal Kanji code,
% \cs{ucs} returns $-1$.
%    \begin{macrocode}
        \if_int_compare:w \tex_ucs:D #1 < 0 \exp_stop_f:
          \prg_return_false:
        \else:
%    \end{macrocode}
% up\TeX{} only. p\TeX{} always false.
%    \begin{macrocode}
          \if_int_compare:w
              \tex_kcatcode:D \tex_ucs:D #1 = 15 \exp_stop_f:
            \prg_return_false:
          \else:
            \prg_return_true:
          \fi:
        \fi:
      }
  }
%    \end{macrocode}
%
% Generate Japanese character token which has Unicode code point \#1.
%    \begin{macrocode}
\int_compare:nNnTF { \tex_jis:D "2121 } = { "3000 }
  {
%    \end{macrocode}
% up\TeX{} with unicode
%    \begin{macrocode}
    \cs_new:Npn \__str_encode_kanji_char:n #1
      {
%    \end{macrocode}
% \cs{Uchar} always generates Latin character token for character
% code $128$--$255$, but Japanese character token are needed,
% so use \cs{Ucharcat} instead.
%    \begin{macrocode}
        \if_int_compare:w \tex_kcatcode:D #1 > 15 \exp_stop_f:
          \tex_Ucharcat:D
            #1 \exp_stop_f: \tex_kcatcode:D #1 \exp_stop_f:
        \else:
          \tex_Ucharcat:D #1 \exp_stop_f: 18 \exp_stop_f:
        \fi:
      }
  }
  {
%    \end{macrocode}
% p\TeX{} or up\TeX{} with euc/sjis
%    \begin{macrocode}
    \cs_new:Npn \__str_encode_kanji_char:n #1
      { \tex_Uchar:D \tex_ucs:D #1 \exp_stop_f: \exp_stop_f: }
  }
%    \end{macrocode}
%
% ptex+utf8 decode function.
%    \begin{macrocode}
\cs_new_protected:cpn { __str_convert_decode_ptex+utf8: }
  {
    \group_begin:
      \cs_set_eq:NN \__str_decode_if_extended_char_p:N
        \__str_decode_if_kanji_char_p:N
      \cs_set_eq:NN \__str_decode_extended_char:N
        \__str_decode_kanji_char:N
      \use:c { __str_convert_decode_utf8: }
    \group_end:
  }
%    \end{macrocode}
%
% Tests whether the token \#1 is Japanese character.
%    \begin{macrocode}
\int_compare:nNnTF { \tex_jis:D "2121 } = { "3000 }
  {
%    \end{macrocode}
% up\TeX{} with unicode
%    \begin{macrocode}
    \prg_new_conditional:Npnn \__str_decode_if_kanji_char:N #1 { p }
      {
        \if_int_compare:w
            \__ptex_char_kcatcode:N #1 > 15 \exp_stop_f:
          \prg_return_true:
        \else:
          \prg_return_false:
        \fi:
      }
  }
  {
%    \end{macrocode}
% p\TeX{} or up\TeX{} with euc/sjis
%    \begin{macrocode}
    \prg_new_conditional:Npnn \__str_decode_if_kanji_char:N #1 { p }
      {
        \if_int_compare:w `#1 < "100 \exp_stop_f:
          \prg_return_false:
        \else:
          \prg_return_true:
        \fi:
      }
  }
%    \end{macrocode}
% Convert Japanese character \#1 to Unicode code point.
%    \begin{macrocode}
\int_compare:nNnTF { \tex_jis:D "2121 } = { "3000 }
  {
%    \end{macrocode}
% up\TeX{} with unicode
%    \begin{macrocode}
    \cs_new:Npn \__str_decode_kanji_char:N #1
      { \int_value:w `#1 }
  }
  {
%    \end{macrocode}
% p\TeX{} or up\TeX{} with euc/sjis
%    \begin{macrocode}
    \cs_new:Npn \__str_decode_kanji_char:N #1
      { \tex_toucs:D `#1 }
  }
%    \end{macrocode}
%
% alternative encoding name
%    \begin{macrocode}
\prop_gput:Nnn \g__str_alias_prop { ptex    } { ptex+utf8 }
%    \end{macrocode}
% set default encoding to ptex+utf8
%    \begin{macrocode}
\prop_gput:Nnn \g__str_alias_prop { default } { ptex+utf8 }
%    \end{macrocode}
%
% \subsection{正規表現関数の修正}
%
% Fix for replacement functions in \file{l3regrex}.
%    \begin{macrocode}
\cs_gset_protected:Npn \__regex_replacement_normal_aux:N #1
  {
    \token_if_eq_charcode:NNTF #1 \c_space_token
      { \__regex_replacement_c_S:w }
      {
%    \end{macrocode}
% Check if the given character token is a jachar.
%    \begin{macrocode}
        \token_if_jachar:NTF #1 
          { \__regex_replacement_jachar:NN }
          {
            \exp_after:wN \exp_after:wN
            \if_case:w \tex_catcode:D `#1 \exp_stop_f:
                 \__regex_replacement_c_O:w
            \or: \__regex_replacement_c_B:w
            \or: \__regex_replacement_c_E:w
            \or: \__regex_replacement_c_M:w
            \or: \__regex_replacement_c_T:w
            \or: \__regex_replacement_c_O:w
            \or: \__regex_replacement_c_P:w
            \or: \__regex_replacement_c_U:w
            \or: \__regex_replacement_c_D:w
            \or: \__regex_replacement_c_O:w
            \or: \__regex_replacement_c_S:w
            \or: \__regex_replacement_c_L:w
            \or: \__regex_replacement_c_O:w
            \or: \__regex_replacement_c_A:w
            \else: \__regex_replacement_c_O:w
            \fi:
          }
      }
    ? #1
  }
%    \end{macrocode}
% 和文文字はとりあえずそのまま出力します。
%    \begin{macrocode}
\cs_new_protected:Npn \__regex_replacement_jachar:NN #1#2
  { \__regex_replacement_put:n {#2} }
%    \end{macrocode}
%
% \subsection{コードポイント関数の修正}
%
% Fix for codepoint functions in \file{l3text}.
%    \begin{macrocode}
%<@@=text>
%    \end{macrocode}
%    \begin{macrocode}
\cs_gset:Npn \@@_codepoint_process:nN #1#2
  {
%    \end{macrocode}
% Check if the given character token is a jachar.
% One jachar token is one codepoint.
%    \begin{macrocode}
    \token_if_jachar:NTF #2
      { \use:n }
      {
        \int_compare:nNnTF { `#2 } > { "80 }
          {
            \int_compare:nNnTF { `#2 } < { "E0 }
              { \@@_codepoint_process:nNN }
              {
                  \int_compare:nNnTF { `#2 } < { "F0 }
                    { \@@_codepoint_process:nNNN }
                    { \@@_codepoint_process:nNNNN }
              }
          }
      }
      { \use:n }
        {#1} #2
  }
%    \end{macrocode}
%    \begin{macrocode}
\cs_gset:Npn \@@_codepoint_compare:N #1
  {
%    \end{macrocode}
% Check if the given character token is a jachar.
%    \begin{macrocode}
    \token_if_jachar:NTF #1
      { \@@_codepoint_compare_jachar:N }
      {
        \if_int_compare:w `#1 > "80 \exp_stop_f:
          \if_int_compare:w `#1 < "E0 \exp_stop_f:
            \exp_after:wN \exp_after:wN \exp_after:wN
              \@@_codepoint_compare:NN
          \else:
            \if_int_compare:w `#1 < "F0 \exp_stop_f:
              \exp_after:wN \exp_after:wN \exp_after:wN
              \exp_after:wN \exp_after:wN \exp_after:wN
              \exp_after:wN \@@_codepoint_compare:NNN
            \else:
              \exp_after:wN \exp_after:wN \exp_after:wN
              \exp_after:wN \exp_after:wN \exp_after:wN
              \exp_after:wN \@@_codepoint_compare:NNNN
            \fi:
          \fi:
        \else:
          \exp_after:wN \@@_codepoint_compare_aux:N
        \fi:
      }
      #1
  }
%    \end{macrocode}
%    \begin{macrocode}
\int_compare:nNnTF { \tex_jis:D "2121 } = { "3000 }
  {
%    \end{macrocode}
% up\TeX{} with unicode.
%    \begin{macrocode}
    \cs_new:Npn \@@_codepoint_compare_jachar:N #1 { `#1 }
  }
  {
%    \end{macrocode}
% p\TeX{} or up\TeX{} with euc/sjis.
%    \begin{macrocode}
    \cs_new:Npn \@@_codepoint_compare_jachar:N #1
      { \tex_toucs:D `#1 \exp_stop_f: }
  }
%    \end{macrocode}
%    \begin{macrocode}
%<@@=>
%    \end{macrocode}
%
% \subsection{l3tl-analysis}
%
% \cs{tl_analysis_map_inline}を和文文字トークンに対応させます。
% 和文文字トークンの場合はカテゴリコードとして和文カテゴリコード
% 16--19（16進数で10--13）を返します。
%    \begin{macrocode}
%<@@=tl>
\cs_gset:Npx \@@_analysis_b_char:Nww #1
  {
    \exp_not:N \token_if_jachar:NTF #1
      {
        \exp_not:N \@@_analysis_b_jachar:N #1
      }
      {
        \exp_not:N \if_meaning:w #1 \exp_not:N \tex_undefined:D
          \token_to_str:N D \exp_not:N \else:
        \exp_not:N \if_catcode:w #1 \c_catcode_other_token
          \token_to_str:N C \exp_not:N \else:
        \exp_not:N \if_catcode:w #1 \c_catcode_letter_token
          \token_to_str:N B \exp_not:N \else:
        \exp_not:N \if_catcode:w #1 \c_math_toggle_token      3
          \exp_not:N \else:
        \exp_not:N \if_catcode:w #1 \c_alignment_token        4
          \exp_not:N \else:
        \exp_not:N \if_catcode:w #1 \c_math_superscript_token 7
          \exp_not:N \else:
        \exp_not:N \if_catcode:w #1 \c_math_subscript_token   8
          \exp_not:N \else:
        \exp_not:N \if_catcode:w #1 \c_space_token
          \token_to_str:N A \exp_not:N \else:
          6
        \exp_not:n { \fi: \fi: \fi: \fi: \fi: \fi: \fi: \fi: }
      }
    \exp_not:N \int_value:w `#1 \s_@@
    \exp_not:N \exp_after:wN \exp_not:N \@@_analysis_b_normals:ww
    \exp_not:N \int_value:w \exp_not:N \int_eval:w - 1 +
  }
%    \end{macrocode}
%
% \begin{macro}{\@@_analysis_b_jachar:N}
%   和文文字トークンの和文カテゴリコードを16進数で取得して、
%   入力ストリームに|{|\meta{kcatecode}|}|を残します。
%    \begin{macrocode}
\sys_if_engine_uptex:TF
  {
%    \end{macrocode}
% up\TeX{}の場合は、予め作っておいた各和文カテゴリコードのトークンと
% カテゴリコードを比較します。
%    \begin{macrocode}
    \cs_new:Npn \@@_analysis_b_jachar:N #1
      {
        \if_catcode:w #1 \c_kcatcode_kanji_token  {10} \else:
        \if_catcode:w #1 \c_kcatcode_kana_token   {11} \else:
        \if_catcode:w #1 \c_kcatcode_symbol_token {12} \else:
          {13}
        \fi: \fi: \fi:
      }
  }
  {
%    \end{macrocode}
% p\TeX{}の場合は、現在の\cs{kcatcode}の設定値を取得します。
%    \begin{macrocode}
    \cs_new:Npn \@@_analysis_b_jachar:N #1
      {
        { \int_to_Hex:n { \tex_kcatcode:D `#1 } }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \file{l3regex}にカテゴリコードが16進一桁を想定したコードがあるのでこれらも対処します。
%    \begin{macrocode}
%<@@=regex>
\cs_gset_protected:Npn \@@_match:n #1
  {
    \@@_match_init:
    \@@_match_once_init:
    \tl_analysis_map_inline:nn {#1}
      { \@@_match_one_token:nnn {##1} {##2} {##3} }
    \@@_match_one_token:nnn { } { -2 } { F }
    \prg_break_point:Nn \@@_maplike_break: { }
  }
\cs_gset_protected:Npn \@@_match_cs:n #1
  {
    \int_set_eq:NN \l_@@_min_thread_int \l_@@_max_thread_int
    \@@_match_init:
    \@@_match_once_init:
    \str_map_inline:nn {#1}
      {
        \tl_if_blank:nTF {##1}
          { \@@_match_one_token:nnn {##1} {`##1} { A } }
          { \@@_match_one_token:nnn {##1} {`##1} { C } }
      }
    \@@_match_one_token:nnn { } { -2 } { F }
    \prg_break_point:Nn \@@_maplike_break: { }
  }
\cs_gset_protected:Npn \@@_match_once_init:
  {
    \if_meaning:w \c_true_bool \l_@@_empty_success_bool
      \cs_set:Npn \@@_if_two_empty_matches:F
        {
          \int_compare:nNnF
            \l_@@_start_pos_int = \l_@@_curr_pos_int
        }
    \else:
      \cs_set_eq:NN \@@_if_two_empty_matches:F \use:n
    \fi:
    \int_set_eq:NN \l_@@_start_pos_int \l_@@_success_pos_int
    \bool_set_false:N \l_@@_match_success_bool
    \tl_set:Nx \l_@@_curr_submatches_tl
      { \prg_replicate:nn { 2 * \l_@@_capturing_group_int } { 0 , } }
    \int_set_eq:NN \l_@@_max_thread_int \l_@@_min_thread_int
    \@@_store_state:n { \l_@@_min_state_int }
    \int_set:Nn \l_@@_curr_pos_int
      { \l_@@_start_pos_int - 1 }
    \int_set_eq:NN \l_@@_curr_char_int \l_@@_last_char_success_int
    \tl_build_get:NN \l_@@_matched_analysis_tl \l_@@_internal_a_tl
    \exp_args:NNf \@@_match_once_init_aux:
    \tl_map_inline:nn
      { \exp_after:wN \l_@@_internal_a_tl \l_@@_curr_analysis_tl }
      { \@@_match_one_token:nnn ##1 }
    \prg_break_point:Nn \@@_maplike_break: { }
  }
\cs_undefine:N \@@_match_one_token:nnN
\cs_gset_protected:Npn \@@_match_one_token:nnn #1#2#3
  {
    \int_add:Nn \l_@@_step_int { 2 }
    \int_incr:N \l_@@_curr_pos_int
    \int_set_eq:NN \l_@@_last_char_int \l_@@_curr_char_int
    \cs_set_eq:NN \@@_maybe_compute_ccc: \@@_compute_case_changed_char:
    \tl_set:Nn \l_@@_curr_token_tl {#1}
    \int_set:Nn \l_@@_curr_char_int {#2}
    \int_set:Nn \l_@@_curr_catcode_int { "#3 }
    \tl_build_put_right:Nx \l_@@_matched_analysis_tl
      { \exp_not:o \l_@@_curr_analysis_tl }
    \tl_set:Nn \l_@@_curr_analysis_tl { { {#1} {#2} {#3} } }
    \use:x
      {
        \int_set_eq:NN \l_@@_max_thread_int \l_@@_min_thread_int
        \int_step_function:nnN
          { \l_@@_min_thread_int }
          { \l_@@_max_thread_int - 1 }
          \@@_match_one_active:n
      }
    \prg_break_point:
    \bool_set_false:N \l_@@_fresh_thread_bool
    \if_int_compare:w \l_@@_max_thread_int > \l_@@_min_thread_int
      \if_int_compare:w -2 < \l_@@_curr_char_int
        \exp_after:wN \exp_after:wN \exp_after:wN \use_none:n
      \fi:
    \fi:
    \l_@@_every_match_tl
  }
\cs_gset_protected:Npn \@@_query_set:n #1
  {
    \int_zero:N \l_@@_balance_int
    \int_zero:N \l_@@_curr_pos_int
    \@@_query_set_aux:nn { } F
    \tl_analysis_map_inline:nn {#1}
      { \@@_query_set_aux:nn {##1} {##3} }
    \@@_query_set_aux:nn { } F
    \int_set_eq:NN \l_@@_max_pos_int \l_@@_curr_pos_int
  }
\cs_undefine:N \@@_query_set_aux:nn
\cs_gset_protected:Npn \@@_query_set_aux:nn #1#2
  {
    \int_incr:N \l_@@_curr_pos_int
    \@@_toks_set:Nn \l_@@_curr_pos_int {#1}
    \__kernel_intarray_gset:Nnn \g_@@_balance_intarray
      { \l_@@_curr_pos_int } { \l_@@_balance_int }
    \if_case:w "#2 \exp_stop_f:
    \or: \int_incr:N \l_@@_balance_int
    \or: \int_decr:N \l_@@_balance_int
    \fi:
  }
\cs_gset_protected:Npn \@@_peek_aux:nnTF #1#2#3#4
  {
    \group_begin:
      \tl_set:Nn \l_@@_peek_true_tl { \group_end: #3 }
      \tl_set:Nn \l_@@_peek_false_tl { \group_end: #4 }
      \@@_single_match:
      #1
      \@@_match_init:
      \tl_build_clear:N \l_@@_input_tl
      \@@_match_once_init:
      \peek_analysis_map_inline:n
        {
          \tl_build_put_right:Nn \l_@@_input_tl
            { \@@_input_item:n {##1} }
          \@@_match_one_token:nnn {##1} {##2} {##3}
          \use_none:nnn
          \prg_break_point:Nn \@@_maplike_break:
            { \peek_analysis_map_break:n {#2} }
        }
  }
%<@@=>
%    \end{macrocode}
%
% 以上です。
%    \begin{macrocode}
%</code>
%    \end{macrocode}
%
% \Finale
%
\endinput
